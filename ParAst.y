-- This Happy file was machine-generated by the BNF converter
{
module ParAst where
import AbsAst
import LexAst
import ErrM
}

%name pProg Prog

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 ',' { PT _ (TS ",") }
 '(' { PT _ (TS "(") }
 ')' { PT _ (TS ")") }
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 '=' { PT _ (TS "=") }
 ';' { PT _ (TS ";") }
 '||' { PT _ (TS "||") }
 '&&' { PT _ (TS "&&") }
 '==' { PT _ (TS "==") }
 '!=' { PT _ (TS "!=") }
 '<' { PT _ (TS "<") }
 '>' { PT _ (TS ">") }
 '<=' { PT _ (TS "<=") }
 '>=' { PT _ (TS ">=") }
 '+' { PT _ (TS "+") }
 '-' { PT _ (TS "-") }
 '*' { PT _ (TS "*") }
 '/' { PT _ (TS "/") }
 '%' { PT _ (TS "%") }
 '!' { PT _ (TS "!") }
 '++' { PT _ (TS "++") }
 '--' { PT _ (TS "--") }
 'boolean' { PT _ (TS "boolean") }
 'double' { PT _ (TS "double") }
 'else' { PT _ (TS "else") }
 'false' { PT _ (TS "false") }
 'for' { PT _ (TS "for") }
 'if' { PT _ (TS "if") }
 'int' { PT _ (TS "int") }
 'return' { PT _ (TS "return") }
 'true' { PT _ (TS "true") }
 'void' { PT _ (TS "void") }
 'while' { PT _ (TS "while") }

L_ident  { PT _ (TV $$) }
L_doubl  { PT _ (TD $$) }
L_integ  { PT _ (TI $$) }
L_quoted { PT _ (TL $$) }
L_err    { _ }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Double  :: { Double }  : L_doubl  { (read $1) :: Double }
Integer :: { Integer } : L_integ  { (read $1) :: Integer }
String  :: { String }  : L_quoted { $1 }

Type :: { Type }
Type : 'int' { Int } 
  | 'boolean' { Boolean }
  | 'double' { Double }
  | 'void' { Void }
  | Type ListPos { Table $1 $2 }


ListPos :: { [Pos] }
ListPos : {- empty -} { [] } 
  | Pos { (:[]) $1 }
  | Pos ListPos { (:) $1 $2 }


Pos :: { Pos }
Pos : '[' Exp ']' { PosF $2 } 
  | '[' ']' { PosE }


ListIdentExp :: { [IdentExp] }
ListIdentExp : {- empty -} { [] } 
  | IdentExp { (:[]) $1 }
  | IdentExp ',' ListIdentExp { (:) $1 $3 }


ListFunc :: { [Func] }
ListFunc : {- empty -} { [] } 
  | Func { (:[]) $1 }
  | Func ListFunc { (:) $1 $2 }


ListInstr :: { [Instr] }
ListInstr : {- empty -} { [] } 
  | Instr { (:[]) $1 }
  | Instr ListInstr { (:) $1 $2 }


ListArg :: { [Arg] }
ListArg : {- empty -} { [] } 
  | Arg { (:[]) $1 }
  | Arg ',' ListArg { (:) $1 $3 }


Arg :: { Arg }
Arg : Type Ident { ArgDecl $1 $2 } 


ListExp :: { [Exp] }
ListExp : {- empty -} { [] } 
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }


Prog :: { Prog }
Prog : ListFunc { Entry $1 } 


Func :: { Func }
Func : Type Ident '(' ListArg ')' Instr { FuncDecl $1 $2 $4 $6 } 


Instr :: { Instr }
Instr : '{' ListInstr '}' { IBlock $2 } 
  | Type ListIdentExp ';' { IDecl $1 $2 }
  | 'return' Exp ';' { IRet $2 }
  | 'return' ';' { IRetEmpty }
  | Exp ';' { IExp $1 }
  | 'if' '(' Exp ')' Instr { IIf $3 $5 }
  | 'if' '(' Exp ')' Instr 'else' Instr { IIfElse $3 $5 $7 }
  | 'while' '(' Exp ')' Instr { IWhile $3 $5 }
  | 'for' '(' Instr Exp ';' Exp ')' Instr { IFor $3 $4 $6 $8 }


IdentExp :: { IdentExp }
IdentExp : Ident { IdentEmpty $1 } 
  | Ident '=' Exp { IdentExp $1 $3 }


Exp :: { Exp }
Exp : Ident '=' Exp { EVarSet $1 $3 } 
  | Ident ListPos '=' Exp { EVarSetTable $1 $2 $4 }
  | Exp1 { $1 }


Exp1 :: { Exp }
Exp1 : Exp1 '||' Exp2 { EOr $1 $3 } 
  | Exp2 { $1 }


Exp2 :: { Exp }
Exp2 : Exp2 '&&' Exp3 { EAnd $1 $3 } 
  | Exp3 { $1 }


Exp3 :: { Exp }
Exp3 : Exp3 '==' Exp4 { EEq $1 $3 } 
  | Exp3 '!=' Exp4 { ENEq $1 $3 }
  | Exp4 { $1 }


Exp4 :: { Exp }
Exp4 : Exp4 '<' Exp5 { ESm $1 $3 } 
  | Exp4 '>' Exp5 { EGr $1 $3 }
  | Exp4 '<=' Exp5 { EESm $1 $3 }
  | Exp4 '>=' Exp5 { EEGr $1 $3 }
  | Exp5 { $1 }


Exp5 :: { Exp }
Exp5 : Exp5 '+' Exp6 { EAdd $1 $3 } 
  | Exp5 '-' Exp6 { ESub $1 $3 }
  | Exp6 { $1 }


Exp6 :: { Exp }
Exp6 : Exp6 '*' Exp7 { EMul $1 $3 } 
  | Exp6 '/' Exp7 { EDiv $1 $3 }
  | Exp6 '%' Exp7 { EMod $1 $3 }
  | Exp7 { $1 }


Exp7 :: { Exp }
Exp7 : '!' Exp7 { ENot $2 } 
  | '+' Exp7 { EPlus $2 }
  | '-' Exp7 { EMinus $2 }
  | Exp7 '++' { EPostPlus $1 }
  | Exp7 '--' { EPostMinus $1 }
  | '++' Exp7 { EPrePlus $2 }
  | '--' Exp7 { EPreMinus $2 }
  | '(' Exp ')' { $2 }
  | Ident ListPos { EVarPos $1 $2 }
  | Ident { EVar $1 }
  | Ident '(' ListExp ')' { ECall $1 $3 }
  | Double { EDouble $1 }
  | Integer { EInt $1 }
  | 'true' { ETrue }
  | 'false' { EFalse }
  | String { EStr $1 }
  | '(' 'int' ')' Exp7 { EToInt $4 }
  | '(' 'boolean' ')' Exp7 { EToBool $4 }
  | '(' 'double' ')' Exp7 { EToDouble $4 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ if null ts then [] else (" before " ++ unwords (map prToken (take 4 ts)))

myLexer = tokens
}

