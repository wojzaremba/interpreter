module SkelAst where

-- Haskell module generated by the BNF converter

import AbsAst
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transType :: Type -> Result
transType x = case x of
  Int  -> failure x
  Boolean  -> failure x
  Double  -> failure x
  Void  -> failure x


transArg :: Arg -> Result
transArg x = case x of
  ArgDecl type' id  -> failure x


transProg :: Prog -> Result
transProg x = case x of
  Entry funcs  -> failure x


transFunc :: Func -> Result
transFunc x = case x of
  FuncDecl type' id args instr  -> failure x


transInstr :: Instr -> Result
transInstr x = case x of
  IBlock instrs  -> failure x
  IDecl type' identexps  -> failure x
  IRet exp  -> failure x
  IRetEmpty  -> failure x
  IExp exp  -> failure x
  IIf exp instr  -> failure x
  IIfElse exp instr0 instr  -> failure x
  IWhile exp instr  -> failure x


transIdentExp :: IdentExp -> Result
transIdentExp x = case x of
  IdentEmpty id  -> failure x
  IdentExp id exp  -> failure x


transExp :: Exp -> Result
transExp x = case x of
  EVarSet id exp  -> failure x
  EOr exp0 exp  -> failure x
  EAnd exp0 exp  -> failure x
  EEq exp0 exp  -> failure x
  ENEq exp0 exp  -> failure x
  ESm exp0 exp  -> failure x
  EGr exp0 exp  -> failure x
  EESm exp0 exp  -> failure x
  EEGr exp0 exp  -> failure x
  EAdd exp0 exp  -> failure x
  ESub exp0 exp  -> failure x
  EMul exp0 exp  -> failure x
  EDiv exp0 exp  -> failure x
  EMod exp0 exp  -> failure x
  ENot exp  -> failure x
  EPlus exp  -> failure x
  EMinus exp  -> failure x
  EPostPlus exp  -> failure x
  EPostMinus exp  -> failure x
  EPrePlus exp  -> failure x
  EPreMinus exp  -> failure x
  EVar id  -> failure x
  ECall id exps  -> failure x
  EDouble d  -> failure x
  EInt n  -> failure x
  ETrue  -> failure x
  EFalse  -> failure x
  EStr str  -> failure x
  EToInt exp  -> failure x



